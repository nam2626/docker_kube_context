# 2주차: 도커(Docker) 이미지와 컨테이너 관리

## 1. 도커 이미지(Docker Image) 만들기

1주차에서 이미지가 컨테이너의 '설계도'라는 것을 배웠습니다. 이제 우리만의 이미지를 직접 만들어 보겠습니다.

### 1.1 Dockerfile이란?

**Dockerfile**은 도커 이미지를 만들기 위한 스크립트 파일입니다. 이 파일에 이미지를 어떻게 만들지 순서대로 명령어를 작성하면, 도커가 그 파일을 읽어 이미지를 자동으로 생성해 줍니다.

### 1.2 Dockerfile의 주요 지시어

| **지시어**      | **설명**                                           | **예시**                                           |
| ------------ | ------------------------------------------------ | ------------------------------------------------ |
| `FROM`       | 이미지를 만들기 위한 **베이스 이미지**를 지정합니다.                  | `FROM ubuntu:22.04`                              |
| `RUN`        | 컨테이너 내부에서 **명령어를 실행**합니다. 보통 패키지 설치에 사용됩니다.      | `RUN apt-get update && apt-get install -y nginx` |
| `COPY`       | **로컬 파일**이나 디렉터리를 이미지로 **복사**합니다.                | `COPY ./html /usr/share/nginx/html`              |
| `EXPOSE`     | 컨테이너가 열어줄 **포트**를 지정합니다.                         | `EXPOSE 80`                                      |
| `WORKDIR`    | 명령어가 실행될 **작업 디렉터리**를 설정합니다.                     | `WORKDIR /app`                                   |
| `CMD`        | 컨테이너가 **시작될 때 실행할 기본 명령어**를 설정합니다.               | `CMD ["nginx", "-g", "daemon off;"]`             |
| `ENTRYPOINT` | 컨테이너가 실행될 때 항상 실행되는 명령어를 설정합니다. `CMD`와 함께 사용됩니다. | `ENTRYPOINT ["/usr/bin/supervisord"]`            |

### 1.3 Dockerfile 작성 예시

#### 예시 1: 간단한 웹 애플리케이션 (Node.js)

```
# 베이스 이미지로 Node.js 20 버전을 사용합니다.
# alpine 버전은 더 가벼운 리눅스 배포판으로 이미지 크기를 줄여줍니다.
FROM node:20-alpine

# 컨테이너의 작업 디렉터리를 /app으로 설정합니다.
WORKDIR /app

# 로컬의 package.json과 package-lock.json 파일을 컨테이너의 /app 디렉터리로 복사합니다.
# 이 두 파일만 먼저 복사하여 종속성 설치 레이어를 캐싱합니다.
COPY package*.json ./

# 필요한 패키지를 설치합니다.
RUN npm install

# 애플리케이션 소스 코드를 컨테이너의 /app 디렉터리로 복사합니다.
# RUN 명령어 이후에 COPY를 배치하여 빌드 효율을 높입니다.
COPY . .

# 컨테이너가 외부에서 3000번 포트를 사용함을 알립니다.
EXPOSE 3000

# 컨테이너가 시작될 때 실행할 명령어를 설정합니다.
CMD ["npm", "start"]
```

#### 예시 2: Python Flask 애플리케이션

```
# 베이스 이미지로 Python 3.10 버전을 사용합니다.
FROM python:3.10-slim

# 컨테이너의 작업 디렉터리를 /app으로 설정합니다.
WORKDIR /app

# 로컬의 requirements.txt 파일을 컨테이너의 /app 디렉터리로 복사합니다.
COPY requirements.txt .

# 필요한 파이썬 패키지를 설치합니다.
RUN pip install --no-cache-dir -r requirements.txt

# 애플리케이션 소스 코드를 컨테이너의 /app 디렉터리로 복사합니다.
COPY . .

# 컨테이너가 외부에서 5000번 포트를 사용함을 알립니다.
EXPOSE 5000

# 컨테이너가 시작될 때 실행할 명령어를 설정합니다.
CMD ["flask", "run", "--host=0.0.0.0"]
```

### 1.4 `docker build` (이미지 빌드)

Dockerfile을 사용하여 이미지를 생성하는 명령어입니다.

- **기본 문법:**
    
    ```
    docker build [옵션] [빌드할 Dockerfile 경로]
    ```
    
- **주요 옵션:**
    
    - `-t [이름]:[태그]` : 빌드된 이미지에 이름과 태그를 부여합니다.
        
    - `-f [파일명]` : Dockerfile의 파일명이 기본 `Dockerfile`이 아닐 경우 사용합니다.
        
- **예시:**
    
    ```
    # 현재 디렉터리의 Dockerfile로 'my-custom-app:1.0' 이미지 빌드
    docker build -t my-custom-app:1.0 .
    ```
    
    > **`.` (점)의 의미:** 현재 디렉터리를 **컨텍스트(Context)**로 사용하겠다는 뜻입니다. 도커는 이 컨텍스트 안에 있는 파일들만 `COPY` 등의 명령어로 이미지에 추가할 수 있습니다.
    
### Dockerfile 실습 예제
node 이미지 기반으로 express 라이브러리 추가하여 간단한 메세지 리턴하는 서버
1. express 설치
	```
	npm i express
	```
2. app.js 작성
```
//app.js
const express = require("express");

const app = express();

const port = 3000;

  

app.get("/", (req, res) => {

  res.send("Hello, Docker!");

});

  

app.listen(port, () => {

  console.log(`Server is listening on http://localhost:${port}`);

});
```
3. 도커파일 작성
```
# DockerFile
# 베이스 이미지 node.js 22버전 지정

FROM node:22

  

# 컨테이너 작업 디렉토리 설정

WORKDIR /app

  

# 로컬의 package.json과 package-lock.json 파일을 컨테이너의 /app 디렉터리로 복사합니다.

# 이 두 파일만 먼저 복사하여 종속성 설치 레이어를 캐싱합니다.

COPY package*.json ./

  

# 패키지 설치

RUN npm install

  

# 애플리케이션 소스 코드를 컨테이너의 /app 디렉터리로 복사합니다.

# RUN 명령어 이후에 COPY를 배치하여 빌드 효율을 높입니다.

COPY . .

  

# 컨테이너가 외부에서 3000번 포트를 사용함을 알립니다.

EXPOSE 3000

  

# 컨테이너가 시작될 때 실행할 명령어를 설정합니다.

CMD ["node", "app.js"]
```
4. 도커파일 빌드
```
docker build -t my-node-app:1.0 .
```
4. 컨테이너 생성 및 접속 테스트
```
docker run -p 9999:3000 -d --name my-node-app-1 my-node-app:1.0
```

### 예제 작업 - 터미널 부분
```
C:\workspace\docker\node>docker build -t my-node-app:1.0 .                    
[+] Building 1.7s (11/11) FINISHED                                                                                                                                                         docker:desktop-linux
 => [internal] load build definition from Dockerfile                                                                                                                                                       0.0s
 => => transferring dockerfile: 795B                                                                                                                                                                       0.0s 
 => [internal] load metadata for docker.io/library/node:22                                                                                                                                                 1.4s 
 => [auth] library/node:pull token for registry-1.docker.io                                                                                                                                                0.0s 
 => [internal] load .dockerignore                                                                                                                                                                          0.0s
 => => transferring context: 2B                                                                                                                                                                            0.0s 
 => [1/5] FROM docker.io/library/node:22@sha256:3266bc9e8bee1acc8a77386eefaf574987d2729b8c5ec35b0dbd6ddbc40b0ce2                                                                                           0.0s 
 => => resolve docker.io/library/node:22@sha256:3266bc9e8bee1acc8a77386eefaf574987d2729b8c5ec35b0dbd6ddbc40b0ce2                                                                                           0.0s 
 => [internal] load build context                                                                                                                                                                          0.1s 
 => => transferring context: 40.66kB                                                                                                                                                                       0.1s 
 => CACHED [2/5] WORKDIR /app                                                                                                                                                                              0.0s 
 => CACHED [3/5] COPY package*.json ./                                                                                                                                                                     0.0s 
 => CACHED [4/5] RUN npm install                                                                                                                                                                           0.0s 
 => CACHED [5/5] COPY . .                                                                                                                                                                                  0.0s 
 => exporting to image                                                                                                                                                                                     0.1s 
 => => exporting layers                                                                                                                                                                                    0.0s 
 => => exporting manifest sha256:d958e5242b254913f9565f56966b2dd769aee709f337004cb20dd4244dc85d1e                                                                                                          0.0s 
 => => exporting config sha256:cf3049dda61fec12d373e5009566407a477652fa47bf74d5c01e6f1e08201e2f                                                                                                            0.0s 
 => => exporting attestation manifest sha256:f897c31a4759bcdd636617ff32a5ab8e8bc326f5005d752875646ded134f090a                                                                                              0.0s 
 => => exporting manifest list sha256:1e9caace433adb2e1fe95323013919dbef0cbddf620f43fcba0a1de797218b89                                                                                                     0.0s 
 => => naming to docker.io/library/my-node-app:1.0                                                                                                                                                         0.0s
 => => unpacking to docker.io/library/my-node-app:1.0                                                                                                                                                      0.0s 

C:\workspace\docker\node>docker images
REPOSITORY    TAG       IMAGE ID       CREATED         SIZE
my-node-app   1.0       1e9caace433a   6 minutes ago   1.63GB
nginx         latest    33e0bbc7ca9e   13 days ago     279MB

C:\workspace\docker\node>docker run -p 9999:3000 -d --name my-node-app-1 my-node-app:1.0   
22e319221e73054892566dc5b3354c149732248ce1238473abc084209a9c6ac3
```
### 폴더 구조
![[Pasted image 20250827151403.png]]

### 접속 테스트
![[Pasted image 20250827151433.png]]
### SpringBoot App 빌드 및 이미지 작성
1. 스프링 부트 프로젝트 생성, SpringWeb만 지정, 포트번호 8888
```
package com.docker;  
  
import org.springframework.web.bind.annotation.GetMapping;  
import org.springframework.web.bind.annotation.RestController;  
  
@RestController  
public class MainController {  
  @GetMapping("/")  
  public String helloDocker() {  
    return "Hello, Docker from Spring Boot!";  
  }  
}
```
2. Dockerfile, .dockerignore 프로젝트 루트 폴더에 작성
```
//Dockerfile
# 스테이지 1: 애플리케이션 빌드  
# Gradle이 미리 설치된 이미지를 사용해 빌드 환경 구축  
FROM gradle:8.5-jdk21 AS builder  
  
# 컨테이너 내 작업 디렉토리 설정  
WORKDIR /app  
  
# Gradle Wrapper 및 소스 코드 복사  
COPY . .  
  
# Gradle을 사용하여 애플리케이션 빌드  
RUN gradle clean build -x test  
  
# 스테이지 2: 최종 이미지 생성  
# 가볍고 JDK 21이 설치된 이미지를 사용  
FROM openjdk:21-jdk-slim  
  
# 컨테이너 내 작업 디렉토리 설정  
WORKDIR /app  
  
# 빌더 스테이지에서 빌드된 JAR 파일을 최종 이미지로 복사  
COPY --from=builder /app/build/libs/*.jar app.jar  
  
# 컨테이너가 외부에서 8080번 포트를 사용함을 알립니다.  
EXPOSE 8080  
  
# 컨테이너 시작 시 JAR 파일 실행  
ENTRYPOINT ["java", "-jar", "app.jar"]
//.dockerignore
HELP.md  
.gradle  
build/  
!gradle/wrapper/gradle-wrapper.jar  
!**/src/main/**/build/  
!**/src/test/**/build/  
  
### STS ###  
.apt_generated  
.classpath  
.factorypath  
.project  
.settings  
.springBeans  
.sts4-cache  
bin/  
!**/src/main/**/bin/  
!**/src/test/**/bin/  
  
### IntelliJ IDEA ###  
.idea  
*.iws  
*.iml  
*.ipr  
out/  
!**/src/main/**/out/  
!**/src/test/**/out/  
  
### NetBeans ###  
/nbproject/private/  
/nbbuild/  
/dist/  
/nbdist/  
/.nb-gradle/  
  
### VS Code ###  
.vscode/
```

폴더구조
![[Pasted image 20250827160243.png]]
3. 도커파일 빌드 후 해당 컨테이너 생성 후 테스트
```
C:\Users\user1\Downloads\docker-ex-web\docker-ex-web>docker build -t spring-app:1.0 .
[+] Building 35.9s (13/13) FINISHED                              docker:desktop-linux
 => [internal] load build definition from Dockerfile                             0.0s
 => => transferring dockerfile: 895B                                             0.0s 
 => [internal] load metadata for docker.io/library/openjdk:21-jdk-slim           1.3s 
 => [internal] load metadata for docker.io/library/gradle:8.5-jdk21              1.7s 
 => [internal] load .dockerignore                                                0.0s
 => => transferring context: 486B                                                0.0s 
 => [builder 1/4] FROM docker.io/library/gradle:8.5-jdk21@sha256:873def2b8a73d  15.5s 
 => => resolve docker.io/library/gradle:8.5-jdk21@sha256:873def2b8a73d00f561604  0.0s 
 => => sha256:e9a5abee61bf67d7bca9f1bfcbfe2a423e1c99180de5cdabea7f7 171B / 171B  0.5s 
 => => sha256:383afd5662614b110ed9dc21c342a876b7a1530385181 132.54MB / 132.54MB  6.9s 
 => => sha256:743987fcab3b7cfcb3cb55668db3620b1a33f8de3206f7f 51.55MB / 51.55MB  3.2s 
 => => sha256:8488d487f914c8366da55bc446a37322924781e278a9f1c3f 4.36kB / 4.36kB  0.6s
 => => sha256:9069ee62a4b7a3620745a2d920573721c3543c6c12659b8884fc7 734B / 734B  0.5s 
 => => sha256:daf2af0ceb31387adbe1068001686aba5c034396442aec6756c7d 174B / 174B  0.6s 
 => => sha256:08e5157807e9b9c65d974d61c154ede442ef90216bfc1 159.59MB / 159.59MB  7.5s 
 => => sha256:26611c45681a8966387aee7b2e1494405e20bc5a46dc5da 17.46MB / 17.46MB  1.6s 
 => => sha256:31bd5f451a847d651a0996256753a9b22a6ea8c65fefb01 30.45MB / 30.45MB  2.1s 
 => => extracting sha256:31bd5f451a847d651a0996256753a9b22a6ea8c65fefb010e77ea9  1.3s 
 => => extracting sha256:26611c45681a8966387aee7b2e1494405e20bc5a46dc5da0af9228  0.7s 
 => => extracting sha256:08e5157807e9b9c65d974d61c154ede442ef90216bfc1a6bf15c90  1.4s 
 => => extracting sha256:daf2af0ceb31387adbe1068001686aba5c034396442aec6756c7d9  0.0s 
 => => extracting sha256:9069ee62a4b7a3620745a2d920573721c3543c6c12659b8884fc7e  0.0s 
 => => extracting sha256:8488d487f914c8366da55bc446a37322924781e278a9f1c3f73912  0.0s 
 => => extracting sha256:743987fcab3b7cfcb3cb55668db3620b1a33f8de3206f7f53c991b  1.7s 
 => => extracting sha256:383afd5662614b110ed9dc21c342a876b7a1530385181278cde6d0  0.7s 
 => => extracting sha256:e9a5abee61bf67d7bca9f1bfcbfe2a423e1c99180de5cdabea7f71  0.0s 
 => [stage-1 1/3] FROM docker.io/library/openjdk:21-jdk-slim@sha256:7072053847  10.9s 
 => => resolve docker.io/library/openjdk:21-jdk-slim@sha256:7072053847a8a05d7f3  0.0s 
 => => sha256:af800cd8441e394f9ec3832393ff933c52e165c096508 204.31MB / 204.31MB  9.0s 
 => => sha256:b4972576c83dad66aa1e4f6d08e74f9e551e721a7cb2dc537 4.01MB / 4.01MB  0.9s 
 => => sha256:a803e7c4b030119420574a882a52b6431e160fceb7620f6 29.12MB / 29.12MB  2.3s 
 => => extracting sha256:a803e7c4b030119420574a882a52b6431e160fceb7620f61b525d4  1.4s 
 => => extracting sha256:b4972576c83dad66aa1e4f6d08e74f9e551e721a7cb2dc5370fe8d  0.2s 
 => => extracting sha256:af800cd8441e394f9ec3832393ff933c52e165c0965089937e3fb1  1.8s 
 => [internal] load build context                                                0.1s 
 => => transferring context: 2.04kB                                              0.0s 
 => [stage-1 2/3] WORKDIR /app                                                   0.3s 
 => [builder 2/4] WORKDIR /app                                                   0.3s 
 => [builder 3/4] COPY . .                                                       0.0s 
 => [builder 4/4] RUN gradle clean build -x test                                16.8s 
 => [stage-1 3/3] COPY --from=builder /app/build/libs/*.jar app.jar              0.1s 
 => exporting to image                                                           1.0s 
 => => exporting layers                                                          0.7s 
 => => exporting manifest sha256:12b9e231b0cc4e4b84f405e6aa111883abb395c622c670  0.0s 
 => => exporting config sha256:f5c58d966995b91c831ab322673c6f47de9b25b6ae895154  0.0s 
 => => exporting attestation manifest sha256:8c87702b57c5bc8334d122f8096f315466  0.0s 
 => => exporting manifest list sha256:2dfa89b85bd12d12b98019ecdb568689e6c2601ed  0.0s 
 => => naming to docker.io/library/spring-app:1.0                                0.0s 
 => => unpacking to docker.io/library/spring-app:1.0                             0.1s 

C:\Users\user1\Downloads\docker-ex-web\docker-ex-web>docker run -d -p 9999:8888 --name spring-app-container spring-app:1.0
d64d4978f592c14e4722739ce3f35e24ed22f8698a26dbde5e741474fd9a5428
```
![[Pasted image 20250827160406.png]]
## flask python 예제
```
// app.py
from flask import Flask, render_template

# Flask 애플리케이션 인스턴스를 생성합니다.
app = Flask(__name__)

# 루트 URL("/")에 대한 라우팅을 설정합니다.
# 사용자가 이 URL로 접속하면 home() 함수가 실행됩니다.
@app.route('/')
def home():
    # 'index.html' 템플릿 파일을 렌더링하여 반환합니다.
    # 템플릿 파일은 'templates' 폴더에 있어야 합니다.
    return render_template('index.html')

  

# '/about' URL에 대한 라우팅을 설정합니다.
@app.route('/about')

def about():

    return '<h1>About Page</h1><p>This is a simple Flask application.</p>'

  

if __name__ == '__main__':

    # 애플리케이션을 실행합니다.

    # debug=True는 개발 모드로, 코드를 수정하면 서버가 자동으로 재시작됩니다.

    app.run(debug=True, host='0.0.0.0')
//template/index.html
<!DOCTYPE html>

<html lang="ko">

  <head>

    <meta charset="UTF-8" />

    <title>Flask Docker 예제</title>

  </head>

  <body>

    <h1>안녕하세요!</h1>

    <p>

      이 웹 페이지는 도커 컨테이너에서 실행 중인 파이썬 플라스크

      애플리케이션입니다.

    </p>

    <a href="/about">About 페이지로 이동</a>

  </body>

</html>

//requirements.txt
Flask

//Dockerfile
# 베이스 이미지로 Python 3.10 버전을 사용합니다.

FROM python:3.10-slim

  

# 컨테이너의 작업 디렉터리를 /app으로 설정합니다.

WORKDIR /app

  

# 로컬의 requirements.txt 파일을 컨테이너의 /app 디렉터리로 복사합니다.

COPY requirements.txt .

  

# 필요한 파이썬 패키지를 설치합니다.

RUN pip install --no-cache-dir -r requirements.txt

  

# 애플리케이션 소스 코드를 컨테이너의 /app 디렉터리로 복사합니다.

COPY . .

  

# 컨테이너가 외부에서 5000번 포트를 사용함을 알립니다.

EXPOSE 5000

  

# 컨테이너가 시작될 때 실행할 명령어를 설정합니다.

CMD ["flask", "run", "--host=0.0.0.0"]

```
### 도커 파일 생성 후 실행 결과
```
D:\docker_kube\docker\python_flask>docker build -t my-flask-app:1.0 .
[+] Building 7.8s (10/10) FINISHED                                                                            docker:desktop-linux 
 => [internal] load build definition from Dockerfile                                                                          0.0s 
 => => transferring dockerfile: 751B                                                                                          0.0s 
 => [internal] load metadata for docker.io/library/python:3.10-slim                                                           0.7s 
 => [internal] load .dockerignore                                                                                             0.0s 
 => => transferring context: 2B                                                                                               0.0s 
 => [1/5] FROM docker.io/library/python:3.10-slim@sha256:420fbb0e468d3eaf0f7e93ea6f7a48792cbcadc39d43ac95b96bee2afe4367da     3.3s
 => => resolve docker.io/library/python:3.10-slim@sha256:420fbb0e468d3eaf0f7e93ea6f7a48792cbcadc39d43ac95b96bee2afe4367da     0.0s 
 => => sha256:3a195ff1e16155a2ca71eee2cc2c4e467119c644d0360b7c2f6e6d9633f9358b 250B / 250B                                    0.5s 
 => => sha256:72e8e193aa94d19c7f1bcbc00737a83d1906bcc1e51965c2873f081eb87bd3a0 14.10MB / 14.10MB                              1.0s 
 => => sha256:7732878f45d9e71f91ce50493915297cca1bde392445d9ddcc0f378a200967bf 1.29MB / 1.29MB                                1.0s 
 => => sha256:396b1da7636e2dcd10565cb4f2f952cbb4a8a38b58d3b86a2cacb172fb70117c 29.77MB / 29.77MB                              1.8s 
 => => extracting sha256:396b1da7636e2dcd10565cb4f2f952cbb4a8a38b58d3b86a2cacb172fb70117c                                     0.8s 
 => => extracting sha256:7732878f45d9e71f91ce50493915297cca1bde392445d9ddcc0f378a200967bf                                     0.1s 
 => => extracting sha256:72e8e193aa94d19c7f1bcbc00737a83d1906bcc1e51965c2873f081eb87bd3a0                                     0.5s 
 => => extracting sha256:3a195ff1e16155a2ca71eee2cc2c4e467119c644d0360b7c2f6e6d9633f9358b                                     0.0s 
 => [internal] load build context                                                                                             0.0s 
 => => transferring context: 177B                                                                                             0.0s 
 => [2/5] WORKDIR /app                                                                                                        0.1s 
 => [3/5] COPY requirements.txt .                                                                                             0.0s 
 => [4/5] RUN pip install --no-cache-dir -r requirements.txt                                                                  2.4s 
 => [5/5] COPY . .                                                                                                            0.0s 
 => exporting to image                                                                                                        1.0s 
 => => exporting layers                                                                                                       0.6s 
 => => exporting manifest sha256:ed1df3b2e390905bb9f834799a9b2d0a12714f01f529087f5058c68a017f9e67                             0.0s 
 => => exporting config sha256:f805124eefba414e11a7879d8bc7fbf0eac81099aa3e85f822d1309ea1f9208e                               0.0s 
 => => exporting attestation manifest sha256:e4f6cd17e2ee5b0b6217cb2d1ef90a8204fe7357e464595562b1d62257826b24                 0.0s 
 => => exporting manifest list sha256:8cda2391be50f96fcb300f1735777c4d95d396ea3ed300460c897bce99b5e003                        0.0s 
 => => naming to docker.io/library/my-flask-app:1.0                                                                           0.0s 
 => => unpacking to docker.io/library/my-flask-app:1.0                                                                        0.3s 

D:\docker_kube\docker\python_flask>docker images
REPOSITORY     TAG       IMAGE ID       CREATED         SIZE
my-flask-app   1.0       8cda2391be50   6 seconds ago   200MB
spring-app     1.0       2dfa89b85bd1   25 hours ago    728MB
my-node-app    1.0       1e9caace433a   26 hours ago    1.63GB
nginx          latest    33e0bbc7ca9e   2 weeks ago     279MB

D:\docker_kube\docker\python_flask>docker run -d -p 9999:5000 --name my-flask-app-1 my-flask-app:1.0 
605bbadb839ba67bc5a33704e575de5c5cfe7f6657f40c3be4ff463c9479d4ed
```

![[Pasted image 20250828172212.png]]
#### 폴더구조
![[Pasted image 20250828172241.png]]

## 2. 도커 컨테이너 데이터 관리: 볼륨(Volume)

컨테이너는 기본적으로 **휘발성**입니다. 즉, 컨테이너가 삭제되면 그 안에 저장된 데이터도 모두 사라집니다. 이러한 문제를 해결하기 위해 **볼륨**을 사용합니다.

### 2.1 볼륨의 필요성

- 컨테이너가 삭제되어도 데이터는 유지되어야 합니다. (예: 데이터베이스)
    
- 호스트와 컨테이너 간에 파일을 공유해야 합니다. (예: 코드 수정)
    

### 2.2 볼륨의 종류와 명령어

- `docker run` 명령의 `-v` 옵션을 사용하여 볼륨을 설정합니다.
    

|   |   |   |
|---|---|---|
|**볼륨 종류**|**설명**|**기본 문법 및 예시**|
|**바인드 마운트**<br>(Bind Mount)|호스트 OS의 **특정 경로**를 컨테이너 내부에 직접 연결합니다. 로컬 파일을 수정하면 컨테이너에도 즉시 반영됩니다.|**문법:** `docker run -v [호스트 경로]:[컨테이너 경로] [이미지 이름]`<br>**예시:** `docker run -v /Users/user/data:/app/data`|
|**명명된 볼륨**<br>(Named Volume)|도커가 관리하는 저장소에 볼륨을 생성하고 이름을 붙여 사용합니다. 주로 데이터베이스와 같은 영속적인 데이터를 보관할 때 사용합니다.|**문법:** `docker run -v [볼륨 이름]:[컨테이너 경로] [이미지 이름]`<br>**예시:** `docker run -v my-db-data:/var/lib/mysql`|

- **볼륨 관련 명령어**
    

|   |   |   |
|---|---|---|
|**명령어**|**설명**|**예시**|
|`docker volume ls`|모든 볼륨 목록을 확인합니다.|`docker volume ls`|
|`docker volume create`|명명된 볼륨을 생성합니다.|`docker volume create my-app-volume`|
|`docker volume inspect`|특정 볼륨의 상세 정보를 확인합니다.|`docker volume inspect my-app-volume`|
|`docker volume rm`|사용하지 않는 볼륨을 삭제합니다.|`docker volume rm my-app-volume`|

## 3. 실습 문제 (Practice Problems) 🧑‍💻

다음 문제들을 직접 해결해 보면서 도커 명령어를 숙달해 보세요. 모든 실습은 터미널(명령 프롬프트 또는 PowerShell)에서 진행합니다.

### 3.1 문제 1: 나만의 Nginx 웹 서버 이미지 만들기

1. 새로운 디렉터리(`my-nginx-app`)를 만들고 이동합니다.
    
2. 그 안에 `Dockerfile` 파일을 생성합니다.
    
3. `Dockerfile`에 다음 내용을 작성하세요.
    
    - `FROM`으로 `nginx:latest` 이미지를 사용합니다.
        
    - `COPY` 명령어로 로컬의 `index.html` 파일을 컨테이너의 Nginx 웹 페이지 경로(`usr/share/nginx/html/index.html`)로 복사합니다.
        
4. `index.html` 파일을 만들고 "Hello, Docker!"와 같은 간단한 문구를 작성합니다.
    
5. `docker build` 명령어를 사용하여 `my-nginx:latest`라는 이름의 이미지를 빌드합니다.
    
6. 빌드한 이미지를 사용하여 컨테이너를 실행하고, 웹 브라우저로 접속하여 "Hello, Docker!" 페이지가 잘 보이는지 확인합니다.
    

### 3.2 문제 2: 볼륨을 사용하여 웹 페이지 실시간 수정하기

1. 문제 1에서 만든 `my-nginx-app` 디렉터리를 사용합니다.
    
2. `docker run` 명령에 **바인드 마운트** 옵션을 추가하여 `index.html` 파일을 컨테이너 내부와 연결합니다.
    
3. 컨테이너를 실행한 후, 웹 브라우저에서 웹 페이지를 확인합니다.
    
4. 이제 **`index.html` 파일을 로컬에서 수정**하고 저장하세요.
    
5. 웹 브라우저에서 페이지를 새로고침하면, 컨테이너를 재시작하지 않아도 변경된 내용이 바로 반영되는 것을 확인할 수 있습니다.
    

### 3.3 문제 3: 사용자 정의 네트워크로 컨테이너 간 통신 시뮬레이션

1. `my-web-db-network`라는 이름의 네트워크를 생성합니다.
    
    - `docker network create ...`
        
2. PostgreSQL 데이터베이스 컨테이너(`postgres:14`)를 `my-db`라는 이름으로 실행하고, **`my-web-db-network`**에 연결합니다.
    
    - `docker run ...`
        
3. Ubuntu 컨테이너를 `test-client`라는 이름으로 실행하고, 마찬가지로 **`my-web-db-network`**에 연결한 뒤 `bash` 셸에 접속합니다.
    
    - `docker run --rm -it --name test-client ...`
        
4. `test-client` 컨테이너 내부에서 `ping my-db` 명령어를 실행하여 데이터베이스 컨테이너와 통신이 되는지 확인합니다.
    
5. 모든 컨테이너와 네트워크를 정리합니다.
    

## 4. 2주차 최종 목표 및 질문

- Dockerfile을 작성하여 나만의 이미지를 만들 수 있나요?
    
- 볼륨의 개념을 이해하고, 바인드 마운트를 사용하여 컨테이너와 호스트 간 데이터를 공유할 수 있나요?
    
- 사용자 정의 네트워크를 생성하고, 컨테이너들을 연결하여 서로 통신시킬 수 있나요?
    

궁금한 점이 있다면 언제든지 질문해주세요!