# 도커(Docker) 및 쿠버네티스(Kubernetes) 입문 및 심화 과정 커리큘럼
### **과정 개요**

이 과정은 컨테이너 기반의 애플리케이션 배포 및 관리를 위한 핵심 기술인 **도커**와 **쿠버네티스**의 기초부터 심화까지 폭넓게 학습합니다. 클라우드 환경에서 효율적인 개발 및 운영을 목표로 하는 개발자, 엔지니어를 위한 단계별 학습 과정입니다.

### **학습 목표**

- 도커를 사용하여 애플리케이션을 컨테이너화하고 관리할 수 있습니다.
    
- 효율적인 도커 이미지를 생성하고 배포할 수 있습니다.
    
- 쿠버네티스 클러스터의 기본 구조와 동작 원리를 이해하고 핵심 오브젝트를 다룰 수 있습니다.
    
- 쿠버네티스 스토리지, 네트워킹, 고급 워크로드 및 패키징 도구를 활용하여 복잡한 애플리케이션을 관리할 수 있습니다.
    
- CI/CD 파이프라인과 도커/쿠버네티스를 연동하는 방법을 이해합니다.
    

### **대상**

- 리눅스 기본 명령어 사용에 익숙한 자
    
- 클라우드 환경에서의 개발 및 운영에 관심 있는 자
    
- 컨테이너 및 컨테이너 오케스트레이션 개념을 기초부터 체계적으로 학습하고자 하는 자
    

### **준비물**

- 인터넷 접속이 가능한 PC
    
- **Docker Desktop** 설치 (Windows/macOS) 또는 리눅스 환경에 도커 및 `docker-compose` 설치
    
- **`kubectl`** 설치 (쿠버네티스 클러스터 제어 도구)
    
- **Minikube** 설치 (로컬 쿠버네티스 클러스터 환경) 또는 Docker Desktop의 쿠버네티스 활성화
    

### **주차별 커리큘럼**

#### **1주차: [[도커(Docker) 시작하기 - 컨테이너 기초]]**

- **기본 학습:**
    
    - 컨테이너 기반 가상화 소개: 가상 머신(VM)과의 차이점, 도커의 필요성
        
    - 도커 아키텍처: **도커 엔진**, **이미지**, **컨테이너**, **도커 레지스트리** (`Docker Hub`)
        
    - 도커 설치 및 설정 (Docker Desktop 또는 Linux)
        
    - 도커 기본 명령어: `docker pull`, `docker run`, `docker ps`, `docker stop`, `docker rm`
        
    - **실습:**
        
        - 도커 설치 확인 및 버전 확인
            
        - `hello-world` 및 Nginx 웹 서버 컨테이너 실행 및 웹 페이지 접속
            
        - 컨테이너 정지, 시작, 삭제 반복 숙달
            
- **심화 내용 (선택 사항):**
    
    - 도커 데몬(Daemon)과 클라이언트(Client)의 관계
        
    - 컨테이너 보안의 기본적인 이해
        

#### **2주차: [[도커 이미지와 컨테이너 관리 - 나만의 이미지 만들기]]**

- **기본 학습:**
    
    - **Dockerfile** 작성법: `FROM`, `RUN`, `COPY`, `EXPOSE`, `CMD`, `ENTRYPOINT` 등 핵심 지시어 이해
        
    - 도커 이미지 빌드 과정 및 **레이어(Layer)** 개념
        
    - 도커 볼륨(Volume): 컨테이너와 호스트 간 데이터 공유 (바인드 마운트, 볼륨)
        
    - 도커 네트워크: 브릿지 네트워크 개념 및 컨테이너 간 통신
        
    - **Docker Hub**를 활용한 이미지 공유: `docker push`, `docker login`
        
    - **실습:**
        
        - 간단한 웹 애플리케이션(Node.js/Python Flask)용 Dockerfile 작성 및 커스텀 이미지 빌드
            
        - 볼륨을 사용하여 웹 애플리케이션의 데이터 영속성 유지
            
        - 생성한 이미지 도커 허브에 푸시 및 다른 환경에서 풀하여 실행
            
- **심화 내용 (선택 사항):**
    
    - 멀티 스테이지 빌드(Multi-stage build)를 이용한 이미지 크기 최적화
        
    - 도커 네트워크 드라이버의 종류 (호스트, 오버레이, None)
        

#### **3주차: 도커 컴포즈(Docker Compose) - 다중 컨테이너 애플리케이션**

- **기본 학습:**
    
    - 단일 컨테이너의 한계 및 멀티 컨테이너 애플리케이션의 필요성
        
    - **Docker Compose** 소개: `docker-compose.yml` 파일 구조 이해
        
    - 서비스, 네트워크, 볼륨 정의 및 컨테이너 간 의존성 설정
        
    - **실습:**
        
        - 웹(Nginx), 백엔드(Node.js/Python), 데이터베이스(MongoDB/PostgreSQL)로 구성된 다중 컨테이너 애플리케이션을 `docker-compose.yml`로 정의
            
        - `docker compose up`, `docker compose down` 명령으로 애플리케이션 실행 및 종료
            
        - `docker compose logs`, `docker compose ps`로 애플리케이션 모니터링
            
- **심화 내용 (선택 사항):**
    
    - 도커 스웜(Docker Swarm)과 같은 오케스트레이션 도구와의 간략한 비교
        
    - Docker Compose 프로덕션 환경에서의 고려사항 (환경 변수 관리 등)
        

#### **4주차: 쿠버네티스(Kubernetes) 기본 개념 및 클러스터 아키텍처**

- **기본 학습:**
    
    - 컨테이너 오케스트레이션의 필요성: 도커와 쿠버네티스의 관계
        
    - **쿠버네티스 아키텍처**: **마스터 노드** (컨트롤 플레인), **워커 노드** (데이터 플레인)
        
    - 마스터 노드 핵심 컴포넌트: **API Server**, **Scheduler**, **Controller Manager**, **etcd**
        
    - 워커 노드 핵심 컴포넌트: **Kubelet**, **Kube-Proxy**, **Container Runtime**
        
    - **`kubectl`** 소개 및 클러스터 연결 확인
        
    - **실습:**
        
        - Docker Desktop 쿠버네티스 활성화 또는 Minikube 설치 및 클러스터 시작
            
        - `kubectl` 설치 및 클러스터 연동 확인 (`kubectl cluster-info`, `kubectl get nodes`)
            
        - 클러스터 내부 정보 확인 (`kubectl describe node [노드 이름]`)
            
- **심화 내용 (선택 사항):**
    
    - 쿠버네티스 선언적(Declarative) 관리 방식의 이해
        
    - 다양한 쿠버네티스 배포 도구 (Kubeadm, kops 등) 간략히 소개
        

#### **5주차: 쿠버네티스 핵심 오브젝트 (Pod, Deployment, Service)**

- **기본 학습:**
    
    - **Pod**: 쿠버네티스에서 배포되는 가장 작은 단위 (컨테이너 그룹)
        
    - **Deployment**: 파드 배포 및 관리, 롤링 업데이트, 롤백 전략
        
    - **Service**: 파드에 안정적인 접근을 제공하는 추상화 (ClusterIP, NodePort, LoadBalancer)
        
    - **YAML** 파일을 이용한 오브젝트 정의 및 `kubectl apply` 사용법
        
    - **실습:**
        
        - 간단한 Nginx 파드 생성 및 삭제 (`kubectl run`, `kubectl delete pod`)
            
        - Nginx 디플로이먼트 생성 및 스케일링 (`kubectl scale`)
            
        - NodePort 타입의 서비스로 Nginx 웹 서버 외부에 노출 및 접속 확인
            
        - 디플로이먼트 이미지 업데이트 및 롤백
            
- **심화 내용 (선택 사항):**
    
    - `livenessProbe`, `readinessProbe`를 활용한 파드 상태 관리
        
    - `Service`의 Selector와 Label의 중요성
        
    - Zero Downtime Deployment 전략
        

#### **6주차: 쿠버네티스 스토리지와 설정 관리**

- **기본 학습:**
    
    - **Volume**: 파드 내부의 휘발성 스토리지 (emptyDir, hostPath)
        
    - **PersistentVolume (PV)**: 클러스터의 영구 스토리지 개념
        
    - **PersistentVolumeClaim (PVC)**: 파드가 PV를 요청하는 방법
        
    - **ConfigMap**: 애플리케이션의 비민감성 설정 관리 (환경 변수, 파일)
        
    - **Secret**: 애플리케이션의 민감성 정보(비밀번호, API 키) 관리
        
    - **실습:**
        
        - `ConfigMap`을 사용하여 웹 애플리케이션 설정 변경
            
        - `Secret`을 사용하여 데이터베이스 비밀번호를 파드에 안전하게 전달
            
        - `PersistentVolume` 및 `PersistentVolumeClaim`을 사용하여 데이터베이스 컨테이너에 영구 스토리지 제공 (Minikube의 hostPath 또는 동적 프로비저닝)
            
- **심화 내용 (선택 사항):**
    
    - 스토리지 클래스(StorageClass)를 이용한 동적 프로비저닝(Dynamic Provisioning)
        
    - CSI (Container Storage Interface) 개념
        

#### **7주차: 쿠버네티스 네트워킹 심화 및 Ingress**

- **기본 학습:**
    
    - 쿠버네티스 내부 DNS 및 서비스 디스커버리(Service Discovery)
        
    - **Ingress** 소개: 외부 트래픽을 클러스터 내부 서비스로 라우팅
        
    - **Ingress Controller**의 역할 (Nginx Ingress Controller 등)
        
    - Ingress Resource 정의: 호스트 기반, 경로 기반 라우팅
        
    - **실습:**
        
        - 두 개의 다른 웹 서비스(예: Nginx, Apache)를 배포
            
        - Ingress Controller 설치 (Minikube의 Addon 또는 직접 설치)
            
        - Ingress Resource를 생성하여 단일 IP로 두 서비스에 접근
            
- **심화 내용 (선택 사항):**
    
    - 네트워크 정책(Network Policy)을 이용한 파드 간 통신 제어
        
    - CNI (Container Network Interface)와 플러그인 (Calico, Cilium 등)
        

#### **8주차: 쿠버네티스 고급 워크로드 관리 (StatefulSet, DaemonSet, Job)**

- **기본 학습:**
    
    - **StatefulSet**: 상태 저장(Stateful) 애플리케이션 배포 및 관리 (데이터베이스, 메시지 큐)
        
    - **DaemonSet**: 모든 노드 또는 특정 노드에 파드를 하나씩 배포 (모니터링 에이전트, 로그 수집기)
        
    - **Job / CronJob**: 일회성 또는 주기적인 작업 실행
        
    - **실습:**
        
        - MySQL 또는 PostgreSQL 데이터베이스를 StatefulSet으로 배포
            
        - 로그 수집기를 DaemonSet으로 배포 (간단한 파일 생성)
            
        - 일회성 배치 작업을 Job으로 실행
            
- **심화 내용 (선택 사항):**
    
    - StatefulSet의 PV Provisioning 및 네트워크 식별자 이해
        
    - 오토스케일링(Horizontal Pod Autoscaler, Vertical Pod Autoscaler) 개념
        

#### **9주차: Helm으로 쿠버네티스 애플리케이션 패키징**

- **기본 학습:**
    
    - 복잡한 쿠버네티스 애플리케이션 배포의 어려움
        
    - **Helm** 소개: 쿠버네티스용 패키지 관리자
        
    - **Chart** 개념: 애플리케이션 배포에 필요한 모든 쿠버네티스 리소스 정의
        
    - Chart 설치, 관리, 업데이트, 삭제
        
    - **실습:**
        
        - Helm 설치 및 Public Chart Repository 추가
            
        - Helm Chart를 사용하여 복잡한 애플리케이션 (예: WordPress, Prometheus) 설치
            
        - 설치된 Chart 설정 변경 및 업데이트
            
- **심화 내용 (선택 사항):**
    
    - Custom Helm Chart 개발 및 Repository 생성
        
    - Helm Chart의 템플릿 언어(Go Template) 이해
        

#### **10주차: CI/CD 파이프라인과 도커/쿠버네티스 연동**

- **기본 학습:**
    
    - **CI/CD (Continuous Integration/Continuous Delivery/Deployment)** 개념 및 중요성
        
    - 도커와 쿠버네티스를 활용한 CI/CD 파이프라인 구축 개요
        
    - **Jenkins**, **GitLab CI/CD**, **GitHub Actions** 등 주요 도구 소개
        
    - **실습:**
        
        - 간단한 웹 애플리케이션 소스 코드 준비
            
        - GitHub Actions를 활용하여 코드 푸시 시 도커 이미지 빌드 및 Docker Hub에 푸시하는 간단한 CI 파이프라인 구축 (이론 및 개념 위주, 실제 배포는 생략)
            
        - 쿠버네티스 디플로이먼트 업데이트 자동화 개념 소개
            
- **심화 내용 (선택 사항):**
    
    - Argo CD 또는 Flux CD와 같은 GitOps 도구 소개
        
    - CI/CD 파이프라인에서의 보안 고려사항
        

### **평가 및 최종 프로젝트**

- **중간 평가:** 도커 이미지 빌드 및 다중 컨테이너 애플리케이션(`docker-compose`) 배포 능력 평가
    
- **최종 프로젝트:**
    
    - 간단한 웹 애플리케이션 (프론트엔드 + 백엔드 + 데이터베이스)을 개발합니다.
        
    - 각 컴포넌트를 도커 이미지로 컨테이너화합니다.
        
    - 쿠버네티스 **Deployment**, **Service**, **ConfigMap**, **Secret**, **PersistentVolumeClaim** 등을 사용하여 클러스터에 배포합니다.
        
    - **Ingress**를 통해 외부에 노출하고, **Helm Chart**로 패키징하여 배포 과정을 자동화합니다.
        
    - (선택 사항) 간단한 CI/CD 파이프라인 아이디어를 구상합니다.